# USE_CASES.md

### Andrew

* Random deck: given that most games have a finite amount of cards to play with, a deck often is comprised of the remaining cards not needed to set up the game. Part of the syntax for what cards to put where is a wildcard ** which will place the remainder of the cards in random order in the designated cell. This allows easy changes from a game of solitaire with a 52 card deck to one with a 100 card deck
* Beginning a game requires the game to be selected in the front end through the GUI. The selection is then passed to the controller which initializes the table with the appropriate ruleset. Select information from that table is then passed to the View to show the user the game has started.
* Every cell has a designation on whether it is sectionable or not. This is important particularly for solitaire where parts of the primary piles must be moved to other piles, but the player's hand cannot be divided in the middle to be used differently. This tag will lead to an attribute in the cell dictating functionality.
* Every game installed will have a different need for space on the screen to play. This information will be provided in the ILayout data class to the View as soon as the game is selected and processed. This will allow for all the front end elements to adjust to a potentially new width and height. 
* Square cards: not all games require the same card dimensions as the traditional playing card. Games such as chess will require square cards to be visually consistent. The engine has the information in the ILayout data class to provide the accurate card height to width ratio to the front end. The further specifics of actual card dimensions will be established by the frontend, but this will keep the shape consistent.
* Flipping Cards: Some cards information need to be obscured from the user, to accomplish this all cards will hold an up or down marker. This will also be accounted for in calls from any public method as a card will swap a value with null if a card is flipped upside down.
* Change Language: Language on the front end should be a mutable preference. This selection would be passed through the IStyle class, which would then change the resource file used for getting language-based strings to the front end.
* One of the possible actions for a cell to do is to give points to a player. These additions can come in the form of additional action tags within the receiver_action tags. This would be accompanied by a point value as a tag beneath it, and processed into the table construction accordingly

### Mariusz

* Some card stacks must be held by individual players (not on the table). This is stored in the configuration file as a location off of the coordinates of the table, and can be rendered in the frontend in these coordinates as such. There may need to be predetermined "special" locations that would be designated as the location for user-held cards to be held
* Stack of cards is shuffled: This is implemented in the backend by the rules, which then shuffle the cards and likely replace them flipped-over in a different location on the board. In the frontend, this appears as merely a series of card flips followed by card movements, which will be implemented via the frontend's internal API.
* The user tries to drag a card to a location where it cannot be moved: The frontend relays this attempted move to the backend, which uses the phase machine to determine how this move should be interpreted. since the move is invalid, no changes are to be registered as a result of this movement, so the frontend does not receive any card movements. thus, the cards that were attempted to be moved are kept in their original location. Optionally, the backend could explicitly register this move as invalid, and the frontend's would be instructed to display a message indicating that the move was invalid (and possible helpful instructions on what move could have been valid)
* Poker Chips/non-rectangular cards: the XML configuration for the game's GUI appearance will have style information about the deck of cards. by default the cards may be opted to be rectangular, but in the case of poker chips or other game pieces, the chips will still be interpreted as cards by the frontend, since they lay on the table and can still be moved around. However, they will be specified in the XML to be circular, and accompanying images can be specified in the xml to make the poker chips render with an appearance resembling a casino chip
* The user quits the current game: This will be registered in the frontend as a specific type of move, which the backend may process and could respond with a command for the frontend to ask the user if they are sure they want to quit, and if they wand their game progress to be saved. the users response to this will also be relayed to the controller, and if the user indicates that they are sure they want to quit, the frontends external API may be used to return to the home page, where the user may pick a new game to play
* The user wins the game: the backend's state machine registers that the previous move should result in the games ending. It can calculate the final positions/scores of the game, and use the frontend's endGame method to signal the ending of the game with the relevant information in order for the frontend to switch to the end of game screen
* The user has specific game-settings that they want to be maintained even after leaving the game and then returning: Since the game's display settings are saved in XML files that are loaded and passed to the frontend at the beginning of the game, the when the user decides to modify these options, these new parameters can be written into an xml file with the same format, and thus reloaded if the user leaves and then returns to the same game. 
* A stack of cards needs to be positioned so that the user can see a portion of each card: Each card is encapsulated as a Cell, which is a tree-like structure that may contain cells underneath. the number of cell locations on the game board is finite. when a card is placed on top of another card, this is represented by a cell being added to the cell. the frontend will register this and use the offset between the cells to display the card as being partially on top of the other card.

### Maverick

* Solitaire card fan: For the game solitaire, the cards need to be placed with an offset such that all the data on the cards is visible. This is stored in the backend as Cells that contain other cells, allowing for tree-like movement and searching.
* User plays a solitaire move: The move is passed to the table, which passes it into the phase machine update, which determines which phase should be used next.
* Getting 3 cards from the deck in solitaire: The cell containing the deck with the extra cards has three cards removed from it. These cards are placed in a cell which has rules to allow for the player to draw.
* The user clicks on a card to flip it: The move received is from a cell to itself. The backend interprets this as a single click, rather than a click and drag, and executes the action associated with clicking, which is the flip method of the card.
* The user makes an invalid move: The phase machine recieves the move and checks it against the given valid rules for the phase. Failing to find the move in the given rules, the phase machine returns a game state indicating the move failed.
* The user clicks the reset button: The controller reads in the same xml file, building another phase machine and table to send to the frontend for rendering.
* A chess player moves a Knight onto an enemy piece: The move is verified against the rules. First, the knight cell is checked to see if it is a valid donor, then the landing cell is checked to see if it was a valid acceptor. Then, the pair is checked for compatibility. Once all of these things are verified, the knight card is moved to the enemy cell, the enemy cell is moved to the discard pile, and if the game has not ended, the next phase indicates the the other player's turn.
* The player draws the last card from the deck, triggering a shuffle: The last card is moved out of the deck, and the phase machine moves into the update phase. This senses that the deck cell is empty, moves all of the discarded cards into it, flips them face down, and shuffles it.

### Sarah

*  Player attempts to move a card: In this case the controller would be informed of the requested move by the getUserInput() function in the front end's external API. In order to know this method holds a new, previously unseen state change, the controller can first call isUserInput() which returns a boolean of whether a new input is ready to be processed.
*  Player loses: When a player loses in a single player game, this signals the end of the game. When this happens, the controller can call endGame() in front end to kick off the appropriate exit sequence - including display of a win/lose message and returning to start menu. However in a multiplayer game, it is possible for a player to lose and the game to continue, in this case the front end has a playerStatusUpdate() function which allows the controller to indicate the change.
*  Game begins: When a game begins, the front end will recieve information about the layout, initial configuration of cards needed to display, and global information about the deck through setLayout() and setStyle() from the controller. The objects passed will be saved and referenced throughout the game.
*  Display names: A player may choose his display name before he begins playing, this name will (when enabled) be used to track high scores and to communicate player status updates. Player IDs, which do not persist across games, will be used to key the players irregardless of their display name.
*  High scores: Players whose game play earns them a high score will be congratulated (if enabled) at the end of their game. The information regarding high scores will be provided by the controller in endGame() as a Map from playerID to playerScore.
*  Quitting: When a player wants to quit, he/she can press a button on the screen which corresponds to them folding or if in single player mode ending the game. This button will have been defined in the Layout.java class and configured on startup. Controller will ask the front end which buttons have been activated in the same fashion getUserInput() is called.
*  Rotating Cards: A card will have a preset rotation value that will allow for a card to be clicked and for that click to translate to a rotation of the card if relevant to the game.
*  Adding card to pile at offset: Each card object is wrapped in a cell object. when a user wants to place card A north of card B, the user may do this by dragging cell A and releasing it over card B. The intersection of cell A and cell B's subcell will be reported to the controlle rin an IMove.

### Tyler

* Reusable Decks: Each XML Rules file for each game will have a "deck" tag. This will have the option of being a filepath to a different deck (which can be reused, e.g. pack52). Alternatively, the deck can be defined there, with each of the cards enumerated, with their own behavior. This parallels much of the functionality offered by other rule components of the XMLs, such as house rules, for example.
* Phase Transitions: Each XML Rules file will include information about phases. Each turn or updating state will be divided into phases. For Solitaire, for instance, there will a start phase, a play phase, a validate phase, and a win phase. Each time cards are moved, the phase logic will be triggered and will proceed to the next phase.
* Card Skins: Each XML Styles file will have a file path to a package containing card skin packs. For the game selected, it will first check this package to determine the skins to use for cards. If this package does not contain the skins for that particular game, the program will check the default skin package for that skin pack. If it is still missing, just the name of the card will be displayed on a shape in place of an image.
* **Phase Donor/Receiver: Each phase will be divided into donor and receiver cards. The player is able to select cards from donor cells and move them into receiver cells. Each phase will hold information about which donor cards are valid and which receiver cells are allowed based on that card and other phase information.**
* Coordinates: In order to allow for flexibility with the display of the front end, all information about where cards should be displayed will be contained in XML files. These files will allow for the construction of an ILayout interface implementation. One of the features of this interface is the storage of a Map of Cell names to locations on the screen. These locations are given by ICoordinates, which hold x and y data relative to the screen width and height. This allows for maximum extensibility for positions and screen size variations.
* Mutable Settings: All styling information may be changed by the user, which may be adjusted in different settings menus. This includes information such as card skins, sound, dark mode, etc. This information will be stored in XML files and will have the option of loading in additional styling data.
* Infinite Games: The player will be able to choose any game from the XML files available in the directory. They will even be able to import XML files from elsewhere such that they may play any (in theory) card game!
* Unstable Games: In the event that a player attempts to load game information that is incomplete or that fails to build a game, an exception will be thrown, which will be caught and displayed to the user so that they know not to repeat such an action.