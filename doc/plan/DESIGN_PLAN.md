# DESIGN_PLAN.md

### Introduction
The goal of this project is to build a game engine in Java which supports a wide variety of card games such as Solitaire, War, Blitz, etc. In addition to providing a framework able to accomodate complex game play rules and interactions, the design will allow for customized colors, decks, and board arrangements.  In order to accomplish this, the design will need to be flexible in both front end and back end, with much of the information required to set up and play defined in xml or other such resource files. The high level architecture will have a model, view, controller breakdown; model will be responsible for maintaining the state of the game, controller will update the state of the game held by model in response to user input provided by view, and view will track user input and display the game table using information provided by the controller. In short, the controller will be the bridge connecting the game state and the players. These components will be well designed to allow for extensions such as multiplayer or non-traditional games with minimal changes to existing solutions, consistent with the open closed principle. The final result will be a game engine which allows a user to develop complex and multifaceted card games by uploading or editing data files related to game rules and display elements. A library of such files will be available to illustrate the flexibility of the underlying Java code's design.

### Overview

The program is divided into three distinct and collaborative modules. Thes include the view, the model, and the controller. The controller manages the data processing from XML and manages the direction of the program, providing it a skeleton to operate around. The view dictates how the program interacts with a user visually and through an interactive GUI. The view gets stylistic data from the controller module, as well as the necessary data about the model by means of a data-oriented class that implements IStyle and ILayout. This allows the view to display the aspects of the game meaningfully. Those aspects of the game are dictated by the model (a Table object), which is initialized by the controller module using a data file of functional rules through the IRuleSet interface. These rules are integrated into the model module so that functionality is a byproduct of the table instead of something that is constantly checked against. 

### Design Details

* View
    * Manages GUI
        * game movements as specified by IMoves generated by the backend
        * toggling between different languages or light/dark mode
    * Displays relevant information
        * table with the current state of the game
        * player scores
        * when relevant, end of game information (winners, losers)
    * Accepts inputs from user
        * user can click on cards, drag cards as part of the gameplay
        * games may have moves that are not triggered by movements on the board, but by clicking between options on the dashboard
            * these options may also include user-inputted values. there will be a range of possible items to place on the dashboard
        * registers when the user takes actions outside of the gameplay, such as toggling the settings to change the language
* Controller
    * Controller
        * Initialize other modules
        * Control dataflow
        * Listen for updates from View
        * Pass actions to Model and update View accordingly
    * Data
        * Define Model rules
        * Provide style preferences to View
        * Provide locations to view
* Model
    * Table
        * Holds cell information, as well as phases
        * Master class for all game data
    * Phase Machine
        * Dictates game logic and rules
        * Follows a finite state machine of phases for game flow
    * Cells
        * Tree-like structure allowing for cascading display and hierarchy of cards

### Example Games

* Solitaire
    * Important Characteristics:
        * Single Player
            * This should be handled by the phase machine, simply returns to the player's turn when it is complete
        * Defined deck
            * Should be loadable into the XML files as it is a frequently used case
        * Compare many card attributes
            * Comparisons are kept in cell definitions given by rules in phases
        * Flexible cell actions/responsibilities
            * Again, dictated by rules in the phases depending on what actions are available
* War
    * Important Characteristics:
        * Multi Player
            * Semi-Simultaneous Play
            * Handled by the phase machine
        * Defined deck
            * Again, loadable from XML file as this one is common
        * Very limited actions
            * Only certain cells will have donor attributes
        * Limited number of cells
            * The number of cells specified in the XML file will be kept to very few (4-6 ideally)
        * Concrete win condition
            * One player runs out of cards, this will be checked in the validation stage to see if one of the two player cells is empty
* Uno
    * Important Characteristics:
        * Multi Player
            * Handled by the phase machine
        * Limited actions
            * Your hand cell only to the discard pile, or deck to your hand cell
        * Strains State Machine (skips, reverse)
            * Will have many more bridges between unique states, but should still be able to be handled through an XML file
        * Concrete win condition
            * One player's hand cell is empty, again checked in the validation stage
        * Non-traditional deck (not typical 52 card)
            * Can be defined in a separate XML file or within the rule file specific to uno since no other game uses this deck
        * Extension challenge: allow for multiple winners in one game (first to finish, next, so on...)
            * Challenges the flexibility of the state machine

### Design Considerations

Design decisions made by the team after some discussion are described below.

1. Card Placement: Discussion over which module is responsible for determining where the cards are placed on the game table was lengthy. On one hand, the relative placement of cards may be relevant to certain game rules, and therefore to controller. In which case, it would also be relevant to the game state in model. However, relative positioning of cards, such as overlapping cards, is different from where to seat a player at the table, and therefore position their hand of cards. This sort of seating, or where a deck is, is not relevant to the back end, and would seem to be more in consistent with the display and styling elements of the front end. The solution was to have back end track what cards or overlapping or at an offset from another, but to encapsulate these groups of cards into a cell. These cells would then be placed according to a layout file whose data would belong to the front end for display purposes.
2. Reporting User Input: There are different levels of granularity at which user input may be passed from front end to back end. There are also different methods front end can use to capture that data, which affect how it will be passed. If, for example, a user would like to draw a card from a deck into their hand, there are many ways to accept this action. The front end can have the player click the draw pile, and then click their hand, or the front end can ask the player to click and drag the card from the deck to the hand. These are basically equivalent in function, and it was decided the initial design would use click and drag for aesthetic purposes. The user's action would be reported to the backend as a vector which points from the drawn pile to the release pile.

Assumptions made by the current design are that a card game consists of game elements (cards) which have at most a color, numeric value, symbol, and name. The configuration of overlapping cards may be relevant to game rules, but their positioning on the table is not. Moves are made by a player moving a card from one place to another (a tap/click is assumed by a player moving a card from location x to location x). It is assumed that cards can either be face up or face down, but will not rest on edges. Player outcomes are similarly binary, either win or lose. Other assumptions include finity in the number of cards, card types, and space on a table. 